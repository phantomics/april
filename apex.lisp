;;;; apex.lisp

(in-package #:apex)
 
(defun is-singleton (value)
  "Determine whether an array is a singleton, i.e. possesses just one member."
  (or (and (atom value)
	   (not (arrayp value)))
      ;; non-array atoms are considered singleton values
      (let ((adims (dims value)))
	(and (= 1 (first adims))
	     (= 1 (length adims))))))

(defun apply-scalar-monadic (function omega)
  "Apply a scalar function across a single arguments, iterating over multidimensional and nested arrays."
  (labels ((apply-fn (arg) (if (arrayp arg)
			       (aops:each #'apply-fn arg)
			       (funcall function arg))))
    (aops:each #'apply-fn omega)))

(defun apply-scalar-dyadic (function alpha omega)
  "Apply a scalar function across objects as appropriate in APL. Handles scalars as well as nested and multidimensional arrays."
  (let* ((alpha-scalar? (not (arrayp alpha)))
	 (omega-scalar? (not (arrayp omega)))
	 (alpha-unitary? (and (not alpha-scalar?)
			      (vectorp alpha)
			      (= 1 (length alpha))))
	 (omega-unitary? (and (not omega-scalar?)
			      (vectorp omega)
			      (= 1 (length omega)))))
    (cond ((and alpha-scalar? omega-scalar?)
	   (funcall function alpha omega))
	  ((and alpha-scalar? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      (vector alpha)
		      omega))
	  ((and alpha-unitary? omega-scalar?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha (vector omega)))
	  ((and alpha-unitary? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha omega))
	  ((and (not alpha-unitary?)
		(not omega-unitary?)
		(not alpha-scalar?)
		(not omega-scalar?))
	   (if (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					       (dims alpha)
					       (dims omega))
		  always dimension)
	       (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
			  alpha omega)
	       (error "Array size mismatch.")))
	  (t (labels ((scan-over (element)
			(if (arrayp element)
			    (aops:each #'scan-over element)
			    (apply (lambda (left right) (apply-scalar-dyadic function left right))
				   (cond (alpha-scalar? (list alpha element))
					 (alpha-unitary? (list (aref alpha 0)
							       element))
					 (omega-scalar? (list element omega))
					 (omega-unitary? (list element (aref omega 0))))))))
	       (aops:each #'scan-over (if (or alpha-scalar? alpha-unitary?)
					  omega alpha)))))))

(defmacro mediate-operation (operation)
  "Process the spec for a function or operator, building a function to process its arguments and generate code to run the operation."
  (flet ((mediate-arguments (operation arg-specs omega-sym &optional alpha-sym)
	   ;; moderate arguments to a Vex function at compile time
	   (let* ((fn (if (and (listp operation)
			       (macro-function (first operation))
			       (not (eql 'lambda (first operation))))
			  (macroexpand (append operation (if (second arg-specs)
							     (list omega-sym alpha-sym)
							     (list omega-sym))))
			  `(function ,operation))))
	     (if (eq :scalar (first arg-specs))
		 ;; for a scalar function, return both monadic and dyadic variants if applicable
		 (if (eq :dyadic (second arg-specs))
		     ``(funcall #'apply-scalar-dyadic ,,fn ,(macroexpand ,omega-sym)
				,(macroexpand ,alpha-sym))
		     ``(funcall #'apply-scalar-monadic ,,fn ,(macroexpand ,omega-sym)))
		 ;; assign the alpha, omega and axis argument specs
		 (let ((alpha (if (not (eq :axes (second arg-specs)))
				  (second arg-specs)))
		       (omega (first arg-specs))
		       (axes (if (eq :axes (second arg-specs))
				 (second arg-specs)
				 (third arg-specs))))
		   ``(if (and ,,@(cond ((eq :one alpha)
					`(`(is-singleton ,(macroexpand ,alpha-sym))))
				       ((eq :sym omega)
					`(`(symbolp (quote ,(if (listp (macroexpand ,omega-sym))
								(second (getf (macroexpand ,omega-sym)
									      :initial-contents))
								(macroexpand ,omega-sym)))))))
			      ,,@(if (and alpha (not (eq :any alpha)))
				     (if (eq :one omega)
					 `(`(is-singleton ,(macroexpand ,omega-sym))))))
			 ;; if the arguments are scalar (:one), remove them from their arrays for evaluation
			 (funcall ,,fn
				  ,,(cond ((eq :one omega)
					   ``(if (arrayp ,(macroexpand ,omega-sym))
						 (aref ,(macroexpand ,omega-sym) 0)
						 ,(macroexpand ,omega-sym)))
					  ((eq :sym omega)
					   ``(quote ,(if (listp (macroexpand ,omega-sym))
							 (second (getf (macroexpand ,omega-sym)
								       :initial-contents))
							 (macroexpand ,omega-sym))))
					  (t `(macroexpand ,omega-sym)))
				  ,,@(if alpha (list (cond ((eq :one alpha)
							    ``(aref ,(macroexpand ,alpha-sym) 0))
							   ((eq :axes alpha)
							    (cons 'list (macroexpand axes)))
							   ;; alpha is equal to :axes when
							   ;; axes are used for a monadic function
							   (t `(macroexpand ,alpha-sym)))))
				  ,,@(if axes (list ``(list ,@(macroexpand axes)))))))))))
  (let* ((operation-name (intern (string-upcase (first operation))
				 "KEYWORD"))
	 (alpha-sym (intern "ALPHA"))
	 (omega-sym (intern "OMEGA"))
	 (valencies (rest operation))
	 (mediated (if (or (eq :symmetric-scalar (first valencies))
			   (eq :asymmetric-scalar (first valencies)))
		       (list (mediate-arguments (if (third valencies)
						    (third valencies)
						    (second valencies))
						(list :scalar :dyadic)
						omega-sym alpha-sym)
			     (mediate-arguments (second valencies)
						(list :scalar :monadic)
						omega-sym))
		       (append (if (second valencies)
		       		   (list (mediate-arguments (first (last (second valencies)))
		       					    (butlast (rest (second valencies)))
		       					    omega-sym alpha-sym)))
		       	       (let ((arg-specs (butlast (rest (first valencies)))))
		       		 (list (apply #'mediate-arguments
		       			      (append (list (first (last (first valencies))))
						      (list (append arg-specs
								    (if (and (eq :scalar (first arg-specs))
									     (eq :dyadic operation-name))
									(list :dyadic)))
							    omega-sym)
						      (if (eq :dyadic operation-name)
							  (list alpha-sym))))))))))
    `(lambda (meta axes omega &optional alpha)
       (declare (ignorable meta axes alpha))
       ,(cond ((eq :monadic operation-name)
	       `(if alpha
		    `(progn (error "Valence error - monadic operation."))
		    ,(first mediated)))
	      ((eq :dyadic operation-name)
	       `(if alpha
		    ,(first mediated)
		    `(error "Valence error - dyadic operation.")))
	      ((eq :ambivalent operation-name)
	       `(if alpha ,@mediated)))))))

(defun numeric-string-p (string)
  "Checks whether the argument is a numeric string."
  (handler-case (progn (parse-apl-number-string string) t)
    (condition () nil)))

(defun parse-apl-number-string (number-string &optional imaginary-component)
  "Parse an APL numeric string into a Lisp value, handling high minus signs and the J-notation for complex numbers."
  (let ((nstring (string-upcase number-string)))
    (if (and (not imaginary-component)
	     (find #\J nstring))
	(let ((halves (cl-ppcre:split "J" nstring)))
	  (if (and (= 2 (length halves))
		   (< 0 (length (first halves)))
		   (< 0 (length (second halves))))
	      (complex (parse-apl-number-string (first halves) t)
		       (parse-apl-number-string (second halves) t))))
	;; either the macron or combining_macron character may be used as the high minus sign
	(parse-number:parse-number (regex-replace-all "[¯̄]" nstring "-")))))

(defun format-value (meta element)
  "Convert a token string into an APL value, paying heed to APL's native ⍺, ⍵ and ⍬ variables."
  (cond ((and (vectorp element)
	      (string= element "⍬"))
	 ;; APL's "zilde" character translates to an empty vector
 	 (make-array (list 0)))
	((and (vectorp element)
	      (or (string= element "⍺")
		  (string= element "⍵")))
	 ;; alpha and omega characters are directly changed to symbols
 	 (intern element))
	((numeric-string-p element)
	 (parse-apl-number-string element))
	((or (and (char= #\" (aref element 0))
		  (char= #\" (aref element (1- (length element)))))
	     (and (char= #\' (aref element 0))
		  (char= #\' (aref element (1- (length element))))))
	 ;; strings are converted to Lisp strings and passed through
	 (subseq element 1 (1- (length element))))
	((stringp element)
	 ;; variable references are converted into generated symbols from the variable table or,
	 ;; if no reference is found in that table, a new reference is created there and a new symbol
	 ;; is generated
	 (if (not (gethash :variables meta))
	     (setf (gethash :variables meta)
		   (make-hash-table :test #'eq)))
	 (let ((variable-found (gethash (intern element "KEYWORD")
					(gethash :variables meta))))
	   (if variable-found variable-found
	       ;; create a new variable if no variable is found matching the string
	       (setf (gethash (intern element "KEYWORD")
			      (gethash :variables meta))
		     (gensym)))))
	(t element)))

(defun format-array (values)
  "Format an APL array, passing through values that are already arrays."
  (if (or (stringp (first values))
	  (symbolp (first values))
	  (and (not (second values))
	       (or (listp (first values))
		   (functionp (first values)))))
      ;; if the first item is a list (i.e. code to generate an array of some kind),
      ;; pass it through with no changes. Also pass through strings, which are already arrays,
      ;; any symbols
      (first values)
      `(make-array (list ,(length values))
		   :initial-contents (list ,@values))))

(defun format-function (idiom-name content)
  "Format an APL function, reversing the order of alpha and omega arguments to reflect the argument order of Lisp as opposed to APL."
  (let ((⍺ (intern "⍺" idiom-name))
	(⍵ (intern "⍵" idiom-name)))
    (lambda (meta axes omega &optional alpha)
      (declare (ignorable meta axes))
      `(funcall (lambda (,⍵ &optional ,⍺)
		  (declare (ignorable ,⍺))
		  ,content)
		,(macroexpand omega)
		,@(if alpha (list (macroexpand alpha)))))))

(defun enclose (item)
  "Enclose non-array values, passing through arguments that are already arrays."
  (if (arrayp item)
      item (vector item)))

(defun disclose (item)
  "Handle APL symbols encountered by the parser. Currently, this means disclosing them if they are singletons referenced in arrays."
  (if (and (arrayp item)
	   (is-singleton item))
      (aref item 0)
      item))

(defun process-output-vector (items)
  "Process items in a vector to be generated by the compiler, wrapping any array references in aplSymbol so that they are disclosed. This does not apply if the output vector is unitary (length 1)."
  (loop for item in items collect (if (and (< 1 (length items))
					   (listp item)
					   (eql 'aref-eliding (first item)))
				      (list 'disclose item)
				      item)))

(defun assemble-value (idiom meta subprocessor precedent exp &optional output axes)
  "Assemble a value from tokens output by the parser; this may be a space-separated vector or a unitary value (processed as a 1-element vector by APL)."
  (if (or (not exp)
	  (and (symbolp (first exp))
	       (member (first exp)
		       (gethash :functions meta)))
	  ;; break if the next symbol represents a function and should be processed by assembleOperation
	  (and (listp (first exp))
	       (keywordp (caar exp))
	       (or (not (eq :axes (caar exp)))
		   (and (listp (second exp))
			(keywordp (caadr exp))))
	       ;; break on axes if the next element is an operation rather than a value
	       (or (not (eq :fn (caar exp)))
		   ;; if the first element in the expression is a function, it's a function composition expression
		   (not (functionp (cadar exp)))
		   output precedent)))
      (values (cond ((not output)
		     (if (and (not precedent)
			      (eq :fn (caar exp)))
			 :fun-comp))
		    ((and (= 1 (length output))
			  ;; disclose strings since they're treated as arrays
			  ;; disclose arrays and lists (which specify computed values)
			  ;; disclose single symbols since any value they represent will be vectorized
			  (or (stringp (first output))
			      (symbolp (first output))
			      (listp (first output))
			      (arrayp (first output))))
		     (first output))
		    ((and (listp (first output))
		    	  (eql 'progn (caar output))
		    	  (eql 'lambda (caadar output)))
		     ;; break if the last element was a composed operation, remove the first element of output,
		     ;; which is instead prepended to the remaining elements in the expression
		     (cons 'vector (process-output-vector (rest output))))
		    (t (cons 'vector (process-output-vector output))))
	      (if (and (listp (first output))
		       (eql 'progn (caar output))
		       (eql 'lambda (caadar output)))
		  ;; if the last element was a composed operation, prepend it to the remaining expression
		  (cons (list :composed-operation (cadar output))
			exp)
		  exp))
      (assemble-value idiom meta subprocessor precedent (rest exp)
		      (cons (cond ((and (listp (first exp))
					(eq :axes (caar exp)))
				   ;; this placeholder keyword is removed in the next iteration
				   :axes-placeholder)
				  ((and (listp (first exp))
					(not (keywordp (caar exp))))
				   ;; if the element is a list and doesn't begin with a keyword,
				   ;; it's a closure and should be handled by the expression processor
				   (let ((enclose
					  (if axes
					      (lambda (body)
						`(aref-eliding ,body
							       (mapcar
								(lambda (vector)
								  (if vector
								      (if (= 1 (length vector))
									  (- (aref vector 0)
									     (of-state *apex-idiom* :count-from))
									  (mapcar (lambda (elem)
										    (- elem (of-state
											     *apex-idiom*
											     :count-from)))
										  (array-to-list vector)))))
								,(cons 'list
								       (rest (funcall subprocessor idiom meta
										      (list axes)))))))
					      #'values)))
				     (funcall enclose (cons 'progn (mapcar (lambda (sub-exp)
									     (funcall subprocessor
										      idiom meta sub-exp))
									   (first exp))))))
				  ((and (listp (first exp))
					(eq :fn (caar exp)))
				   `(lambda (omega &optional alpha)
				      ,(funcall (cadar exp)
						meta nil 'omega 'alpha)))
				  ((symbolp (first exp))
				   (if axes
				       `(aref-eliding (disclose ,(first exp))
						      (mapcar (lambda (vector)
								(if vector
								    (- (aref vector 0)
								       ,(of-state *apex-idiom* :count-from))))
							      ,(cons 'list (rest (funcall subprocessor idiom meta
											  (list axes))))))
				       ;; symbol preprocessing is not applied to ⍺ and ⍵
				       ;; since they represent arguments to a function that already went
				       ;; through processing
				       (if (or (eql '⍺ (first exp))
					       (eql '⍵ (first exp))
					       (and (not output)
						    (not precedent)))
					   ;; don't disclose unitary vectors if the expression content is ⍺ or ⍵
					   ;; and thus referring to preprocessed variables or if the symbol is
					   ;; the only element in the expression,with no output or
					   ;; precedent present.
					   (first exp)
					   `(disclose ,(first exp)))))
				  (t (if axes
					 `(aref-eliding ,(first exp)
							(mapcar (lambda (item) (aref item 0))
								,(cons 'list
								       (rest (funcall subprocessor idiom meta
										      (list axes))))))
					 (first exp))))
			    ;; :axes-placeholder is removed here if axes are being processed this iteration
			    (if axes (rest output)
				output))
		      (if (and (listp (first exp))
			       (eq :axes (caar exp)))
			  (cdar exp)))))

(defun assemble-operation (idiom meta subprocessor precedent exp &key (axes nil) (from-pivot nil))
  "Assemble an APL operation from parsed tokens. The simplest operations consist of a single function, like '+', while operators can be combined with functions to form more complex operations."
  (let ((head (first exp))
	(next (second exp))
	(tail (rest exp)))
    (macrolet ((get-function (symbol)
		 `(let ((function (if (or (characterp ,symbol)
					  (symbolp ,symbol))
				      (of-functions idiom ,symbol)
				      ,symbol)))
		    (if axes (lambda (meta unused omega &optional alpha)
			       (declare (ignore unused))
			       (funcall function meta
					(rest (funcall subprocessor idiom meta (list axes)))
					omega alpha))
			function))))
      (cond ((symbolp head)
	     ;; if the head is a function-denoting symbol, wrap the symbol in the appropriate function call
	     ;; syntax and return it with the tail
	     (values (lambda (meta axes omega &optional alpha)
		       (declare (ignore meta axes))
		       `(funcall ,head ,omega ,@(if alpha (list alpha))))
		     tail))

	    ((and (eq :composed-operation (first head)))
	     ;; if the head is a composed operation, wrap appropriately and return with the tail
	     (values (lambda (meta axes omega &optional alpha)
		       (declare (ignore meta axes))
		       `(funcall ,(second head) ,omega ,@(if alpha (list alpha))))
		     tail))
	    
	    ((eq :axes (first head))
	     ;; if an axes object is found, process the next item in the list with the :axes option
	     ;; filled with the found object
	     (multiple-value-bind (following-axes from-following-axes)
		 (assemble-operation idiom meta subprocessor precedent tail :axes (list (second head)))
	       (values following-axes from-following-axes)))

	    ((and (eq :fn (first head))
		  (or (not tail)
		      (not (listp next))
		      (not (and (listp next)
				(keywordp (first next))))
		      (and (eq :axes (first next))
			   (or (not (listp (second tail)))
			       (not (keywordp (first (second tail))))))
		      (eq :fn (first next))
		      (and (eq :op (first next))
			   (eq :right (second next)))))
	     ;; finish assembling the operation if the token list is at its end, the next item is not a
	     ;; function or operator, or the next item is another function or right operand
	     (values (get-function (second head))
		     tail))

	    ((and (eq :fn (first head))
		  (eq :op (first next))
		  (eq :center (second next)))
	     ;; if the next glyph is a center operator glyph, perform the first stage of its assembly
	     ;; and then execute the resulting operation on the head glyph, thus completing the assembly
	     (multiple-value-bind (following-op from-following-op)
		 (assemble-operation idiom meta subprocessor precedent tail)
	       (values (funcall following-op meta (cons 'list axes)
				(get-function (second head)))
		       from-following-op)))

	    ((and (eq :op (first head))
	    	  (or from-pivot (not (eq :center (second head))))
	    	  ;; note: center operator glyphs cannot be overloaded as function glyphs if they follow
	    	  ;; another center operator glyph
	    	  (or (not tail)
	    	      (not (and (listp next)
	    			(eq :fn (first next))))))
	     ;; if no function follows a right operator glyph, check whether it's actually an overloaded
	     ;; function glyph and reassign if so
	     (if (of-overloaded? idiom (first (last head)))
	    	 (values (get-function (first (last head)))
	    		 tail)
	    	 (error "Found operator with no accompanying function.")))

	    ((eq :op (first head))
	     ;; handle any other operator
	     (multiple-value-bind (following-op from-following-op)
		 (if (and (listp next)
			  (keywordp (first next)))
		     (assemble-operation idiom meta subprocessor precedent tail :from-pivot t)
		     (assemble-value idiom meta subprocessor precedent tail))
	       (values (funcall (of-operators idiom (first (last head)))
				meta (cons 'list (mapcar (lambda (item) (cons 'vector item))
							 axes))
				following-op)
		       from-following-op)))))))

(defun left-invert-matrix (in-matrix)
  (let* ((input (if (= 2 (rank in-matrix))
		   in-matrix (make-array (list (length in-matrix) 1)
					 :element-type (element-type in-matrix)
					 :initial-contents (loop for i from 0 to (1- (length in-matrix))
							      collect (list (aref in-matrix i))))))
	 (result (array-inner-product
		  (invert-matrix (array-inner-product (aops:permute (reverse (iota (rank input)))
								    input)
						      input
						      (lambda (arg1 arg2) (apply-scalar-dyadic #'* arg1 arg2))
						      #'+))
		  (aops:permute (reverse (iota (rank input)))
				input)
		  (lambda (arg1 arg2) (apply-scalar-dyadic #'* arg1 arg2))
		  #'+)))
    (if (= 1 (rank in-matrix))
	(aref (aops:split result 1) 0)
	result)))

;; (defun compose-stage (function-form left-operand)
;;   (lambda (meta unused omega &optional alpha)
;;     (declare (ignore unused alpha))
;;     (print (list :eg function-form left-operand omega
;; 		 (funcall left-operand meta nil 'omega 'alpha)))
;;     (cond ((and (not function-form)
;; 		(not (functionp left-operand)))
;; 	   ;; mode 2: curry function with left argument
;; 	   (setq function-form
;; 		 `(funcall (lambda (omega alpha) ,(funcall omega meta nil 'omega 'alpha))
;; 			   ,left-operand omega))
;; 	   (compose-stage function-form left-operand))
;; 	  ((and (not function-form)
;; 		(not (functionp omega)))
;; 	   ;; mode 3: curry function with right argument
;; 	   `(lambda (omega)
;; 	      (declare (ignorable alpha))
;; 	      (funcall (lambda (omega alpha) ,(funcall left-operand meta nil 'omega 'alpha))
;; 		       omega ,omega)))
;; 	  ((and (not function-form)
;; 		(functionp left-operand))
;; 	   (setq function-form
;; 		 `(funcall (lambda (omega)
;; 			     ,(funcall left-operand meta nil 'omega))
;; 			   (funcall (lambda (omega)
;; 				      ,(funcall omega meta nil 'omega))
;; 				    omega)))
;; 	   (compose-stage function-form left-operand))
;; 	  ((functionp omega)
;; 	   (setq function-form
;; 		 `(funcall (lambda (omega) ,(funcall omega meta nil 'omega))
;; 			   ,function-form))
;; 	   (compose-stage function-form left-operand))
;; 	  ((eq :fun-comp omega)
;; 	   `(lambda (omega &optional alpha)
;; 	      (declare (ignorable alpha))
;; 	      ,function-form))
;; 	  ((or (listp omega)
;; 	       (symbolp omega))
;; 	   ;; a list passed as omega means that a calculated value is
;; 	   ;; on the right side of the composite
;; 	   `(funcall (lambda (omega &optional alpha)
;; 		       (declare (ignorable alpha))
;; 		       ,function-form)
;; 		     ,omega))
;; 	  (t (compose-stage function-form left-operand)))))

(defun compose-stage (left-operand)
  (let* ((left-evaluated (funcall left-operand nil :marker 'omega 'alpha))
	 (functions nil))
    (lambda (meta unused right-operand &optional alpha)
      (declare (ignore meta unused alpha))
      (lambda (meta &optional axes omega alpha)
	;; (print (list :om omega alpha axes left-operand right-operand))
	(if (not (eq :fun-comp omega))
	    (setq functions (if (functionp (first left-evaluated))
				(cons right-operand left-evaluated)
				(list right-operand left-operand))))
	(labels ((wrap (with-alpha fnlist body)
		   (if fnlist
		       (wrap with-alpha (rest fnlist)
			     `(funcall (lambda (omega ,@(if (and with-alpha (not (rest fnlist)))
						      (list 'alpha)))
					 ,(if (functionp (first fnlist))
					      (funcall (first fnlist)
						       meta nil 'omega (if (and with-alpha (not (rest fnlist)))
									   'alpha))
					      (first fnlist)))
				       ,@(if (and with-alpha (not (rest fnlist)))
					     (list 'alpha-comp))
				       ,body))
		       body)))
	  (if (not (eq :marker axes))
	      (funcall (if (eq :fun-comp omega)
			   #'values (lambda (body) `(funcall ,body ,omega ,alpha)))
		       `(lambda (omega-comp &optional alpha-comp)
			  (if alpha-comp
			      ,(wrap t (if (functionp (first left-evaluated))
					   left-evaluated (list left-operand))
				     `(funcall (lambda (omega) ,(funcall right-operand meta nil 'omega))
					       omega-comp))
			      ,(wrap nil (if (functionp (first left-evaluated))
					     left-evaluated
					     (list left-operand))
				     `(funcall (lambda (omega) ,(funcall right-operand meta nil 'omega))
					       omega-comp)))))
	      functions))))))

(vex-spec
 apex

 (state :count-from 1
	:disclose-output t
	:atomic-vector
	(concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
		     "abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏£⊥⍶⌶⍐⍑χ≢⍖⍗"
		     "⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣◊┘┌█▄▌▐▀"
		     "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))

 (utilities :match-blank-character
	    (lambda (char) (member char (list #\  #\Tab)))
	    :match-newline-character
	    (lambda (char) (member char (list #\◊ #\Newline #\Return)))
	    :match-token-character
	    (lambda (char)
	      ;; the ¯ character must be expressed as #\macron to be correctly processed
	      ;; the ̄ (combining_macron) character can be denoted normally, however
	      (or (alphanumericp char)
		  (member char (list #\macron #\̄ #\. #\⍺ #\⍵ #\⍬))))
	    :prep-code-string
	    (lambda (string)
	      ;; this code preprocessor removes comments, including comment-only lines
	      (regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
				 string ""))
	    :process-axis-string
	    (lambda (string) (cl-ppcre:split #\; string))
	    :format-value #'format-value
	    :format-object #'format-array
	    :format-function #'format-function
	    :mediate-operation-macro 'mediate-operation
	    :assemble-value #'assemble-value
	    :assemble-operation #'assemble-operation
	    :apply-scalar-monadic #'apply-scalar-monadic
	    :apply-scalar-dyadic #'apply-scalar-dyadic
	    :postprocess-compiled
	    (lambda (form)
	      ;; wrap the last element of the compiled output in a disclose form if discloseOutput is set
	      (if (of-state *apex-idiom* :disclose-output)
		  (append (butlast form)
			  (list (list 'disclose (first (last form)))))
		  form))
	    :postprocess-value
	    (lambda (item)
	      (if (of-state *apex-idiom* :disclose-output)
		  (list 'disclose item)
		  item)))

 (functions (← (has :title "Assign")
	       (dyadic (macro (lambda (meta axes omega alpha)
	    			(declare (ignorable axes))
	    			(if (and (listp alpha)
	    				 (eql 'aref-eliding (first alpha)))
	    			    (append alpha (list :set omega))
	    			    (let ((symbol (if (listp alpha)
	    					      (second alpha)
	    					      alpha)))
	    			      (if (or (eql 'lambda (first omega))
	    				      (and (listp (second omega))
	    					   (eql 'lambda (caadr omega))))
	    				  ;; assign from either a disclosed or enclosed function definition,
	    				  ;; i.e. a←⍴∘⍴ or a←(⍴∘⍴).
	    				  (setf (gethash :functions meta)
	    					(cons symbol (gethash :functions meta))))
	    			      `(setq ,symbol ,omega))))))
	       (tests (is "x←55 ◊ x" 55)
	    	      (is "x←2 3 4⍴⍳9 ◊ x[;1;]←7 ◊ x" #3A(((7 7 7 7) (5 6 7 8) (9 1 2 3))
	    						  ((7 7 7 7) (8 9 1 2) (3 4 5 6))))))
	    (⊣ (has :titles ("Empty" "Left"))
	       (ambivalent (args :any (lambda (omega)
	    				(declare (ignore omega))
	    				(make-array (list 0))))
	    		   (args :any :any (lambda (omega alpha)
	    				     (declare (ignore omega))
	    				     alpha)))
	       (tests (is "⊣77" #())
		      (is "55⊣77" 55)))
	    (⊢ (has :titles ("Identity" "Right"))
	       (ambivalent (args :any (lambda (omega) omega))
	    		   (args :any :any (lambda (omega alpha)
	    				     (declare (ignore alpha))
	    				     omega)))
	       (tests (is "⊢77" 77)
		      (is "55⊢77" 77)))
	    (+ (has :titles ("Identity or Negate Imaginary" "Add"))
	       (ambivalent :asymmetric-scalar (lambda (omega) (if (complexp omega)
								  (complex (realpart omega)
									   (- (imagpart omega)))
								  omega))
			   +)
	       (tests (is "+5" 5)
		      (is "+5J2" #C(5 -2))
		      (is "1+1" 2)
		      (is "1+1 2 3" #(2 3 4))))
    	    (- (has :titles ("Negate" "Subtract"))
	       (ambivalent :symmetric-scalar (reverse-op -))
	       (tests (is "2-1" 1)
		      (is "7-2 3 4" #(5 4 3))))
     	    (× (has :titles ("Direction" "Multiply"))
	       (ambivalent :asymmetric-scalar signum *)
	       (tests (is "×20 5 0 ¯5 5 ¯9" #(1 1 0 -1 1 -1))
		      (is "2×3" 6)
		      (is "4 5×8 9" #(32 45))))
     	    (÷ (has :titles ("Reciprocal" "Divide"))
	       (ambivalent :symmetric-scalar (reverse-op /))
	       (tests (is "6÷2" 3)
		      (is "12÷6 3 2" #(2 4 6))
		      (is "÷2 4 8" #(1/2 1/4 1/8))))
     	    (⋆ (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp (reverse-op expt))
	       (tests (is "⌊1000×⋆2" 7389)
		      (is "2⋆4" 16)
		      (is "⌊16⋆÷2" 4)))
     	    (* (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp (reverse-op expt)))
     	    (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
	       (ambivalent :symmetric-scalar log)
	       (tests (is "⌊1000×⍟5" 1609)
		      (is "⌊2⍟8" 3)))
     	    (\| (has :titles ("Magnitude" "Residue"))
	    	(ambivalent :asymmetric-scalar abs mod)
		(tests (is "|55" 55)
		       (is "|¯33" 33)
		       (is "8|39" 7)))
     	    (! (has :titles ("Factorial" "Binomial"))
	       (ambivalent :asymmetric-scalar sprfact (reverse-op binomial))
	       (tests (is "!5" 120)
		      (is "5!12" 792)))
     	    (⌈ (has :titles ("Ceiling" "Maximum"))
	       (ambivalent :asymmetric-scalar ceiling (reverse-op max))
	       (tests (is "⌈1.0001" 2)
		      (is "⌈1.9998" 2)
		      (is "3⌈0 1 2 3 4 5" #(3 3 3 3 4 5))))
     	    (⌊ (has :titles ("Floor" "Minimum"))
	       (ambivalent :asymmetric-scalar floor (reverse-op min))
	       (tests (is "⌊1.0001" 1)
		      (is "⌊1.9998" 1)
		      (is "3⌊0 1 2 3 4 5" #(0 1 2 3 3 3))))
 	    (? (has :titles ("Random" "Deal"))
 	       (ambivalent (args :scalar (lambda (omega)
 	    				   (+ (random omega)
 	    				      (of-state *apex-idiom* :count-from))))
 	    		   (args :one :one (lambda (omega alpha)
 	    				     (make-array (list alpha)
 	    						 :initial-contents
 	    						 (loop for i from 0 to (1- alpha)
 	    						    collect (+ (random omega)
 	    							       (of-state *apex-idiom* :count-from))))))))
     	    (○ (has :titles ("Pi Times" "Circular"))
 	       (ambivalent (args :scalar (lambda (omega) (* pi omega)))
 	    		   (args :any :one (lambda (omega alpha)
 	    				     (let ((fn (vector (lambda (input) (exp (* input #C(0 1))))
 	    						       (lambda (input) (* input #C(0 1)))
 	    						       (lambda (input) (if (complexp input)
 	    									   (complex (realpart input)
 	    										    (- (imagpart input)))
 	    									   input))
 	    						       #'values
 	    						       (lambda (input) (expt (- -1 (* 2 input))
 	    									     1/2))
 	    						       #'atanh #'acosh #'asinh
 	    						       (lambda (input) (* (expt (/ (1+ input) (1- input))
 	    										1/2)
 	    									  (1+ input)))
 	    						       #'atan #'acos #'asin
 	    						       (lambda (input) (expt (- 1 (* 2 input))
 	    									     1/2))
 	    						       #'sin #'cos #'tan
 	    						       (lambda (input) (expt (1+ (* 2 input))
 	    									     1/2))
 	    						       #'sinh #'cosh #'tanh
 	    						       (lambda (input) (expt (- -1 (* 2 input))
 	    									     1/2))
 	    						       #'realpart #'abs #'imagpart #'phase)))
 	    				       ;; the twelfth element of the vector corresponds to
 	    				       ;; index 0, hence an offset of 12 from the vector's first element
 	    				       (apply-scalar-monadic (aref fn (+ 12 alpha))
 								     omega)))))
 	       (tests (is "⌊100000×○1" 314159)
 		      ;;(is "(⌊1000×1÷2⋆÷2)=⌊1000×1○○÷4" 1)
		      ))
 	    (\~ (has :titles ("Not" "Excluding"))
 	    	(ambivalent (args :scalar
 				  (boolean-op (lambda (omega)
 						(cond ((= 0 omega) t)
 						      ((= 1 omega) nil)
 						      (t (error
 							  "Domain error: arguments to ~ must be 1 or 0."))))))
 	    		    (args :any :any (lambda (omega alpha)
 	    				      (let ((to-exclude (if (stringp omega)
 	    							    (array-to-list omega)
 	    							    (array-to-list (make-array
 	    									    (list (array-total-size omega))
 	    									    :displaced-to omega))))
 	    					    (included nil))
 	    					(aops:each (lambda (element)
 	    						     (if (not (member element to-exclude))
 	    							 (setq included (cons element included))))
 	    						   alpha)
 	    					(make-array (list (length included))
 	    						    :element-type (element-type alpha)
 	    						    :initial-contents (reverse included))))))
 	    	(tests (is "~1 0 1" #(0 1 0))
 	    	       (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
 	    	       (is "'MACARONI'~'ALFREDO'" "MCNI")))
     	    (< (has :title "Less")
 	       (dyadic (args :scalar (reverse-boolean-op <)))
 	       (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
     	    (≤ (has :title "Less or Equal")
 	       (dyadic (args :scalar (reverse-boolean-op <=)))
 	       (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
     	    (= (has :title "Equal")
 	       (dyadic (args :scalar (reverse-boolean-op (lambda (omega alpha)
 	    					   (cond ((and (numberp alpha)
 	    						       (numberp omega))
 	    						  (= alpha omega))
 	    						 ((and (characterp alpha)
 	    						       (characterp omega))
 	    						  (char= alpha omega)))))))
 	       (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
     	    (≥ (has :title "Greater or Equal")
 	       (dyadic (args :scalar (reverse-boolean-op >=)))
 	       (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
     	    (> (has :title "Greater")
 	       (dyadic (args :scalar (reverse-boolean-op >)))
 	       (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
     	    (≠ (has :title "Not Equal")
 	       (dyadic (args :scalar (reverse-boolean-op /=)))
 	       (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
 	    (≡ (has :titles ("Depth" "Match"))
 	       (ambivalent (args :any array-depth)
 	    		   (args :any :any (reverse-boolean-op array-compare))))
 	    (≢ (has :titles ("First Dimension" "Not Match"))
 	       (ambivalent (args :any (lambda (omega) (first (dims omega))))
 			   (args :any :any (boolean-op (lambda (omega alpha)
 							 (not (array-compare alpha omega)))))))
 	    (^ (has :title "And")
 	       (dyadic (args :scalar (reverse-op lcm)))
 	       (tests (is "0 1 0 1 ^ 0 0 1 1" #(0 0 0 1))))
 	    (∧ (has :title "And")
 	       (dyadic (args :scalar (reverse-op lcm)))
 	       (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
 	    (⍲ (has :title "Nand")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha) (not (= alpha omega 1))))))
 	       (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
     	    (∨ (has :title "Or")
 	       (dyadic (args :scalar (reverse-op gcd)))
 	       (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
 	    (⍱ (has :title "Nor")
 	       (dyadic (args :scalar (boolean-op (lambda (omega alpha) (= alpha omega 0)))))
 	       (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
 	    (⍳ (has :titles ("Index" "Index Of"))
 	       (ambivalent (args :one (lambda (omega)
 	    				(make-array (list omega)
 	    					    :initial-contents
 	    					    (alexandria:iota omega
								     :start (of-state *apex-idiom*
										      :count-from)))))
			   (args :any :any index-of))
 	       (tests (is "⍳5" #(1 2 3 4 5))
 	    	      (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
     	    (⍴ (has :titles ("Shape" "Reshape"))
 	       (ambivalent (args :any (lambda (omega)
 					(let ((omega-dims (dims omega)))
 					  (make-array (list (length omega-dims))
 						      :initial-contents omega-dims))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (reshape-array-fitting omega (array-to-list alpha)))))
 	       (tests (is "⍴1 2 3" 3)
 		      (is "⍴3 5⍴⍳8" #(3 5))
 		      (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
 	    (⌷ (has :title "At Axes")
 	       (dyadic (args :any :any :axes
 			     (lambda (omega alpha &optional axes)
 			       (if axes
 				   (let ((elided-coords (loop for i from 0 to (1- (rank omega))
 							   collect nil)))
 				     (loop for index from 0 to (1- (length (first axes)))
 					do (setf (nth (- (aref (first axes) index)
 							 (of-state *apex-idiom* :count-from))
 						      elided-coords)
 						 (- (aref alpha index)
 						    (of-state *apex-idiom* :count-from))))
 				     (aref-eliding omega elided-coords))
 				   (let* ((coords (mapcar (lambda (coord) (- coord
 									     (of-state *apex-idiom* :count-from)))
 							  (array-to-list alpha)))
 					  (found (apply #'aref (cons omega coords))))
 				     (if (not (arrayp found))
 					 (vector found)
 					 found))))))
 	       (tests (is "3⌷⍳9" 3)
 		      (is "2 2⌷4 5⍴⍳9" 7)
 		      (is "2 3 4⌷4 5 6⍴⍳9" 1)
 		      (is "1 3⌷[1 2]2 3 4⍴⍳5" #(4 5 1 2))))
 	    (∊ (has :titles ("Enlist" "Membership"))
 	       (ambivalent (args :any enlist)
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (let ((output (make-array (dims alpha))))
 	    				       (dotimes (index (array-total-size output))
 	    					 (let ((found nil))
 	    					   (aops:each (lambda (input)
 	    							(cond ((and (numberp input)
 	    								    (numberp (row-major-aref alpha index))
 	    								    (= input (row-major-aref alpha index)))
 	    							       (setq found t))
 	    							      ((and (characterp input)
 	    								    (characterp (row-major-aref alpha
 													index))
 	    								    (char= input
 	    									   (row-major-aref alpha index)))
 	    							       (setq found t))))
 	    						      omega)
 	    					   (setf (row-major-aref output index)
 	    						 (if found 1 0))))
 	    				       output))))
 	       (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
 	    	      (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
 	    (⍷ (has :title "Find")
 	       (dyadic (args :any :any find-array))
 	       (tests (is "(2 2⍴6 7 1 2)⍷2 3 4⍴⍳9" #3A(((0 0 0 0) (0 1 0 0) (0 0 0 0))
 						       ((0 0 1 0) (0 0 0 0) (0 0 0 0))))))
 	    (↑ (has :titles ("Disclose" "Take"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (or (not (vectorp omega))
 	    					(not (arrayp (aref omega 0))))
 	    				    omega (aref omega 0))))
 	    		   (args :any :any :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (multidim-slice omega (if axes
 							     (loop for axis from 0 to (1- (rank omega))
 								collect (if (= axis (- (aref (first axes) 0)
 										       (of-state *apex-idiom*
 												 :count-from)))
 									    (aref alpha 0)
 									    (nth axis (dims omega))))
 							     (array-to-list alpha))
 	    					   :fill-with 0))))
 	       (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
 	    	      (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
 	    				       ((4 5 6 7) (1 2 3 4) (7 8 9 1))))
 		      (is "1↑[1]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
 		      (is "1↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4)) ((4 5 6 7))))
 		      (is "2↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8)) ((4 5 6 7) (8 9 1 2))))
 		      (is "2↑[3]2 3 4⍴⍳9" #3A(((1 2) (5 6) (9 1)) ((4 5) (8 9) (3 4))))))
 	    (↓ (has :titles ("Split" "Drop"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (aops:split omega (if axes (aref (first axes) 0)
 	    							    (1- (rank omega))))))
 	    		   (args :any :any :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (multidim-slice omega
 						   (if axes (loop for axis from 0 to (1- (rank omega))
 							       collect (if (= axis (- (aref (first axes) 0)
 										      (of-state *apex-idiom*
 												:count-from)))
 									   (aref alpha 0)
 									   0))
 						       (array-to-list alpha))
 	    					   :inverse t))))
 	       (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
 	    	      (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
 	    				       ((6 7 8 9) (3 4 5 6) (9 1 2 3))))
 		      (is "1↓[1]2 3 4⍴⍳9" #3A(((4 5 6 7) (8 9 1 2) (3 4 5 6))))
 		      (is "1↓[2]2 3 4⍴⍳9" #3A(((5 6 7 8) (9 1 2 3)) ((8 9 1 2) (3 4 5 6))))
 		      (is "2↓[2]2 3 4⍴⍳9" #3A(((9 1 2 3)) ((3 4 5 6))))
 		      (is "2↓[3]2 3 4⍴⍳9" #3A(((3 4) (7 8) (2 3)) ((6 7) (1 2) (5 6))))))
 	    (\, (has :titles ("Ravel" "Catenate or Laminate"))
 	    	(ambivalent (args :any :axes
 				  (lambda (omega &optional axes)
 				    (ravel (of-state *apex-idiom* :count-from)
 					   omega axes)))
 	    		    (args :any :any :axes
 	    			  (lambda (omega alpha &optional axes)
 	    			    (if (and (or (not axes)
 						 (integerp (aref (first axes) 0)))
 					     (vectorp alpha)
 	    				     (vectorp omega))
 	    				(if (and axes (< 0 (- (aref (first axes) 0)
 							      (of-state *apex-idiom* :count-from))))
 					    (error (concatenate
 						    'string "Specified axis is greater than 1, vectors"
 						    " have only one axis along which to catenate."))
 					    (if (and axes (> 0 (- (aref (first axes) 0)
 								  (of-state *apex-idiom* :count-from))))
 						(error (format nil "Specified axis is less than ~a."
 							       (of-state *apex-idiom* :count-from)))
 						(concatenate 'vector alpha omega)))
 	    				(if (or (not axes)
 						(integerp (aref (first axes) 0)))
 					    (aops:stack (if axes (- (aref (first axes) 0)
 								    (of-state *apex-idiom* :count-from))
 							    1)
 							alpha omega)
 					    ;; laminate in the case of a fractional axis argument
 					    (let* ((axis (ceiling (- (aref (first axes) 0)
 								     (of-state *apex-idiom* :count-from))))
 						   (permute-dims (alexandria:iota (1+ (rank alpha))))
 						   (p-alpha (if (not (is-singleton alpha))
 								(aops:permute (rotate-right axis permute-dims)
 									      (array-promote alpha))))
 						   (p-omega (if (not (is-singleton omega))
 								(aops:permute (rotate-right axis permute-dims)
 									      (array-promote omega)))))
 					      ;; a 1-element array argument to laminate is scaled to
 					      ;; match the other array's dimensions
 					      (aops:stack axis
 							  (if (is-singleton alpha)
 							      (scale-array alpha p-omega)
 							      p-alpha)
 							  (if (is-singleton omega)
 							      (scale-array omega p-alpha)
 							      p-omega))))))))
 	    	(tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
 		       (is ",[0.5]3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
 		       (is ",[1.5]3 4⍴⍳9" #3A(((1 2 3 4)) ((5 6 7 8)) ((9 1 2 3))))
 		       (is ",[2.5]3 4⍴⍳9" #3A(((1) (2) (3) (4)) ((5) (6) (7) (8)) ((9) (1) (2) (3))))
 		       (is ",[1 2]2 3 3⍴⍳12" #2A((1 2 3) (4 5 6) (7 8 9) (10 11 12) (1 2 3) (4 5 6)))
 		       (is ",[2 3]2 3 3⍴⍳12" #2A((1 2 3 4 5 6 7 8 9) (10 11 12 1 2 3 4 5 6)))
 		       (is ",[1 2 3]2 3 3⍴⍳12" #(1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6))
 	    	       (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
 	    					 (1 2 3 4 5 6 9 1 2 3)))
 		       (is "(5 4⍴⍳6),[1]3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
 						    (5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		       (is "1 2 3,4 5 6" #(1 2 3 4 5 6))
 		       (is "1 2 3,[1]4 5 6" #(1 2 3 4 5 6))
 		       (is "1 2 3 4,[0.5]1 2 3 4" #2A((1 2 3 4) (1 2 3 4)))
 		       (is "1 2 3 4,[1.5]1 2 3 4" #2A((1 1) (2 2) (3 3) (4 4)))
 		       (is "(2 3⍴⍳9),[0.5]2 3⍴⍳9" #3A(((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))))
 		       (is "(2 3⍴⍳9),[2.5]2 3⍴⍳9" #3A(((1 1) (2 2) (3 3)) ((4 4) (5 5) (6 6))))
 		       (is "'UNDER',[0.5]'-'" #2A((#\U #\N #\D #\E #\R) (#\- #\- #\- #\- #\-)))
 		       (is "'HELLO',[1.5]'.'" #2A((#\H #\.) (#\E #\.) (#\L #\.) (#\L #\.) (#\O #\.)))))
     	    (⍪ (has :titles ("Table" "Catenate First"))
 	       (ambivalent (args :any (lambda (omega) (if (vectorp omega)
 	    						  (make-array (list (length omega) 1)
 								      :element-type (element-type omega)
 	    							      :initial-contents
 	    							      (loop for i from 0 to (1- (length omega))
 	    								 collect (list (aref omega i))))
 	    						  (let ((o-dims (dims omega)))
 							    (make-array (list (first o-dims)
 									      (apply #'* (rest o-dims)))
 									:element-type (element-type omega)
 									:displaced-to (copy-array omega))))))
 	    		   (args :any :any :axes
 				 (lambda (omega alpha &optional axes)
 				   (if (and (vectorp alpha)
 					    (vectorp omega))
 				       (if axes
 					   (error "Axis arguments not accepted when catenating vectors.")
 					   (concatenate 'vector alpha omega))
 				       (aops:stack (if axes (- (aref (first axes) 0)
 							       (of-state *apex-idiom* :count-from))
 						       0)
 						   alpha omega)))))
 	       (tests (is "⍪'MAKE'" #2A((#\M) (#\A) (#\K) (#\E)))
 		      (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		      (is "⍪2 3 4⍴⍳24" #2A((1 2 3 4 5 6 7 8 9 10 11 12)
 					   (13 14 15 16 17 18 19 20 21 22 23 24)))
 	    	      (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
 	    					(5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
 		      (is "(3 6⍴⍳6)⍪[2]3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
 						   (1 2 3 4 5 6 9 1 2 3)))))
 	    (/ (has :title "Replicate")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state *apex-idiom* :count-from)))))
 	    				     0 :compress-mode t))))
 	       (tests (is "5/3" #(3 3 3 3 3))
 		      (is "1 0 1 0 1/⍳5" #(1 3 5))
 		      (is "3/⍳5" #(1 1 1))
 		      (is "3/⊂⍳5" #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))
 	    	      (is "1 ¯2 3 ¯4 5/3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))
 		      (is "1 ¯2 3/[1]3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
 						 (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))))
 	    (⌿ (has :title "Replicate First")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state *apex-idiom* :count-from)))))
 	    				     (1- (rank omega))
 	    				     :compress-mode t))))
 	       (tests (is "1 0 1 0 1⌿⍳5" #(1 3 5))
 		      (is "1 ¯2 3⌿3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
 					      (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))
 		      (is "1 ¯2 3 ¯4 5⌿[2]3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
 						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))))
 	    (\\ (has :title "Expand")
 	    	(dyadic (args :any :any :axes
 	    		      (lambda (omega alpha &optional axes)
 	    			(expand-array (array-to-list alpha)
 	    				      omega (if axes (- (rank omega)
 	    							(- (aref (first axes) 0)
 	    							   (1- (of-state *apex-idiom* :count-from)))))
 	    				      0))))
 		(tests (is "1 ¯2 3 ¯4 5\\ '.'" ".  ...    .....")
 		       (is "1 ¯2 2 0 1\\3+2 3⍴⍳6" #2A((4 0 0 5 5 0 6) (7 0 0 8 8 0 9)))
 		       (is "1 0 1\\[1]3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
 	    (⍀ (has :title "Expand First")
 	       (dyadic (args :any :any :axes
 	    		     (lambda (omega alpha &optional axes)
 	    		       (expand-array (array-to-list alpha)
 	    				     omega (if axes (- (rank omega)
 	    						       (- (aref (first axes) 0)
 	    							  (1- (of-state *apex-idiom* :count-from)))))
 	    				     (1- (rank omega))))))
 	       (tests (is "1 ¯2 3 ¯4 5⍀3" #(3 0 0 3 3 3 0 0 0 0 3 3 3 3 3))
 		      (is "1 0 1⍀3+2 3⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
 	    (⍧ (has :title "Partitioned Enclose")
 	       (dyadic (args :any :any :axes
 			     (lambda (omega alpha &optional axes)
 			       (partitioned-enclose alpha omega
 						    (if axes (- (rank omega)
 								(- (aref (first axes) 0)
 								   (1- (of-state *apex-idiom* :count-from)))))
 						    0))))
 	       (tests (is "0 1 0 0 1 1 0 0 0⍧⍳9" #(#(2 3 4) #(5) #(6 7 8 9)))
 		      (is "0 1 0 0 1 1 0 0 0⍧4 8⍴⍳9"
 			  #(#2A((2 3 4) (1 2 3) (9 1 2) (8 9 1)) #2A((5) (4) (3) (2))
 			    #2A((6 7 8) (5 6 7) (4 5 6) (3 4 5))))
 		      (is "0 1 0 1 0⍧[1]4 8⍴⍳9"
 			  #(#2A((9 1 2 3 4 5 6 7) (8 9 1 2 3 4 5 6)) #2A((7 8 9 1 2 3 4 5))))))
 	    (⊂ (has :titles ("Enclose" "Partition"))
 	       (ambivalent (args :any :axes
 				 (lambda (omega &optional axes)
 				   (if axes
 				       (re-enclose omega (aops:each (lambda (axel)
 								      (- axel (of-state *apex-idiom* :count-from)))
 								    (first axes)))
 				       (if (loop for dim in (dims omega) always (= 1 dim))
 					   omega (make-array (list 1) :initial-element omega)))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (if (/= (length alpha) (length omega))
 	    					 (error "Length mismatch.")
 	    					 (let ((output nil)
 	    					       (accumulator nil)
 	    					       (partition-index 0))
 	    					   (dotimes (index (length alpha))
 	    					     (if (and (< 0 index)
 	    						      (< partition-index (aref alpha index)))
 	    						 (progn (setq output
 	    							      (cons (make-array (list (length accumulator))
 	    										:initial-contents
 	    										(reverse accumulator))
 	    								    output))
 	    							(setq accumulator nil)))
 	    					     (setq partition-index (aref alpha index))
 	    					     (if (< 0 (aref alpha index))
 	    						 (setq accumulator (cons (aref omega index)
 	    									 accumulator))))
 	    					   (if accumulator (setq output
 	    								 (cons (make-array
 	    									(list (length accumulator))
 	    									:initial-contents
 	    									(reverse accumulator))
 	    								       output)))
 	    					   (make-array (list (length output))
 	    						       :initial-contents (reverse output)))))))
 	       (tests (is "1,⊂3 4⍴⍳7" #(1 #2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
 		      (is "⊂[3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GRAY" "GOLD" "BLUE") ("SILK" "WOOL" "YARN")))
 		      (is "⊂[2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GGB" "ROL" "ALU" "YDE") ("SWY" "IOA" "LOR" "KLN")))
 		      (is "⊂[1]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #2A(("GS" "RI" "AL" "YK") ("GW" "OO" "LO" "DL") ("BY" "LA" "UR" "EN")))
 		      (is "⊂[2 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\R #\A #\Y) (#\G #\O #\L #\D) (#\B #\L #\U #\E))
 			    #2A((#\S #\I #\L #\K) (#\W #\O #\O #\L) (#\Y #\A #\R #\N))))
 		      (is "⊂[1 3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\R #\A #\Y) (#\S #\I #\L #\K))
 			    #2A((#\G #\O #\L #\D) (#\W #\O #\O #\L))
 			    #2A((#\B #\L #\U #\E) (#\Y #\A #\R #\N))))
 		      (is "⊂[1 2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
 			  #(#2A((#\G #\G #\B) (#\S #\W #\Y)) #2A((#\R #\O #\L) (#\I #\O #\A))
 			    #2A((#\A #\L #\U) (#\L #\O #\R)) #2A((#\Y #\D #\E) (#\K #\L #\N))))
 	    	      (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
 	    (⊃ (has :titles ("Mix" "Pick"))
 	       (ambivalent (args :any :axes
 				 (lambda (omega &optional axes)
 				   (mix-arrays (if axes (ceiling (- (1+ (rank omega))
 								    (aref (first axes) 0)
 								    (of-state *apex-idiom* :count-from)))
 						   0)
 					       omega)))
 	    		   (args :any :any (lambda (omega alpha)
 					     (labels ((layer-index (object indices)
 							(if indices
 							    (layer-index (aref object (- (first indices)
 											 (of-state *apex-idiom*
 												   :count-from)))
 									 (rest indices))
 							    object)))
 					       (let ((found (layer-index omega (array-to-list alpha))))
 						 (if (arrayp found)
 						     found (make-array (list 1)
 								       :element-type (element-type omega)
 								       :initial-element found)))))))
 	       (tests (is "⊃(1)(1 2)(1 2 3)" #2A((1 0 0) (1 2 0) (1 2 3)))
 		      (is "⊃[0.5](1)(1 2)(1 2 3)" #2A((1 1 1) (0 2 2) (0 0 3)))
 		      (is "⊃(2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
 						  ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
 		      (is "⊃[0.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 4 0 0) (1 3 5 7)) ((2 5 0 0) (2 4 6 8))
 						       ((3 1 0 0) (0 0 0 0))))
 		      (is "⊃[1.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
 						       ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
 		      (is "⊃2 2 2⍴(1)(1 2)(3 4)(1 2 3)" #4A((((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))
 							    (((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))))
 		      (is "2⊃(1 2 3)(4 5 6)(7 8 9)" #(4 5 6))
 		      (is "(2 2)⊃(1 2 3)(4 5 6)(7 8 9)" 5)))
 	    (∪ (has :titles ("Unique" "Union"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (not (vectorp omega))
 	    				    (error "Argument must be a vector.")
 	    				    (let ((uniques nil))
 	    				      (dotimes (index (length omega))
 	    					(if (not (find (aref omega index)
 	    						       uniques :test #'array-compare))
 	    					    (setq uniques (cons (aref omega index)
 	    								uniques))))
 	    				      (make-array (list (length uniques))
 							  :element-type (element-type omega)
 	    						  :initial-contents (reverse uniques))))))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (if (or (not (vectorp alpha))
 	    					     (not (vectorp omega)))
 	    					 (error "Arguments must be vectors.")
 	    					 (let ((uniques nil)
 						       (is-string (and (eql 'character (element-type alpha))
 								       (eql 'character (element-type omega)))))
 	    					   (dotimes (index (length omega))
 	    					     (if (not (find (aref omega index)
 	    							    alpha :test #'array-compare))
 	    						 (setq uniques (cons (aref omega index)
 	    								     uniques))))
 	    					   (concatenate (if is-string 'string 'vector)
 								alpha
 	    							(make-array (list (length uniques))
 									    :element-type (if is-string
 											      'character t)
 	    								    :initial-contents
 	    								    (reverse uniques))))))))
 	       (tests (is "∪1 2 3 4 5 1 2 8 9 10 11 7 8 11 12" #(1 2 3 4 5 8 9 10 11 7 12))
 		      (is "∪'MISSISSIPPI'" "MISP")
 		      (is "3 10 14 18 11∪9 4 5 10 8 3" #(3 10 14 18 11 9 4 5 8))
 		      (is "'STEEL'∪'SABER'" "STEELABR")
 		      (is "'APRIL' 'MAY'∪'MAY' 'JUNE'" #("APRIL" "MAY" "JUNE"))))
 	    (∩ (has :title "Intersection")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (if (or (not (vectorp alpha))
 	    					 (not (vectorp omega)))
 	    				     (error "Arguments must be vectors.")
 	    				     (let ((matches nil)
 						   (is-string (and (eql 'character (element-type alpha))
 								   (eql 'character (element-type omega)))))
 	    				       (dotimes (index (length alpha))
 	    					 (if (find (aref alpha index)
 	    						   omega :test #'array-compare)
 	    					     (setq matches (cons (aref alpha index)
 	    								 matches))))
 	    				       (make-array (list (length matches))
 							   :element-type (if is-string 'character t)
 	    						   :initial-contents (reverse matches)))))))
 	       (tests (is "'MIXTURE'∩'LATER'" "TRE")
 		      (is "'STEEL'∩'SABER'" "SEE")
 		      (is "1 4 8∩⍳5" #(1 4))))
 	    (⌽ (has :titles ("Reverse" "Rotate"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (if (vectorp omega)
 	    					  (let ((new-array (copy-array omega)))
 	    					    (funcall (make-rotator)
 	    						     new-array)
 	    					    new-array)
 	    					  (if (arrayp omega)
 	    					      (apply-marginal (make-rotator)
 	    							      omega (if axes (1- (aref (first axes) 0)))
 	    							      (1- (rank omega)))))))
 	    		   (args :any :one :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (if (vectorp omega)
 	    			       (let ((new-array (copy-array omega)))
 	    				 (funcall (make-rotator alpha)
 	    					  new-array)
 	    				 new-array)
 	    			       (if (arrayp omega)
 	    				   (apply-marginal (make-rotator alpha)
 	    						   omega (if axes (1- (aref (first axes) 0)))
 	    						   (1- (rank omega))))))))
 	       (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
 	    	      (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
 	    	      (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))))
     	    (⊖ (has :titles ("Reverse First" "Rotate First"))
 	       (ambivalent (args :any :axes (lambda (omega &optional axes)
 	    				      (if (vectorp omega)
 	    					  (let ((new-array (copy-array omega)))
 	    					    (funcall (make-rotator)
 	    						     new-array)
 	    					    new-array)
 	    					  (if (arrayp omega)
 	    					      (apply-marginal (make-rotator)
 	    							      omega (if axes (1- (aref (first axes) 0)))
 	    							      0)))))
 	    		   (args :any :one :axes
 	    			 (lambda (omega alpha &optional axes)
 	    			   (if (vectorp omega)
 	    			       (let ((new-array (copy-array omega)))
 	    				 (funcall (make-rotator alpha)
 	    					  new-array)
 	    				 new-array)
 	    			       (if (arrayp omega)
 	    				   (apply-marginal (make-rotator alpha)
 	    						   omega (if axes (1- (aref (first axes) 0)))
 	    						   0))))))
 	       (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
 	    	      (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
 	    	      (is "1⊖3 4⍴⍳9" #2a((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
 	    (⍉ (has :titles ("Transpose" "Permute"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(aops:permute (reverse (alexandria:iota (rank omega)))
 	    					      omega)))
 	    		   (args :any :any (lambda (omega alpha)
 	    				     (aops:permute (mapcar (lambda (i)
 	    							     (- i (of-state *apex-idiom* :count-from)))
 	    							   (array-to-list alpha))
 	    						   omega))))
 	       (tests (is "⍉2 3 4⍴⍳9" #3A(((1 4) (5 8) (9 3)) ((2 5) (6 9) (1 4))
 					  ((3 6) (7 1) (2 5)) ((4 7) (8 2) (3 6))))
 		      (is "1 3 2⍉2 3 4⍴⍳9" #3A(((1 5 9) (2 6 1) (3 7 2) (4 8 3))
 					       ((4 8 3) (5 9 4) (6 1 5) (7 2 6))))))
 	    (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
 	       (ambivalent (args :any (lambda (omega)
 	    				(if (and (= 1 (rank omega))
 	    					 (= 1 (length omega)))
 	    				    (/ (aref omega 0))
 	    				    (if (< 2 (rank omega))
 						(error "Matrix inversion only works on arrays of rank 2 or 1.")
 						(if (let ((odims (dims omega)))
 						      (and (= 2 (length odims))
 							   (= (first odims) (second odims))))
 						    (invert-matrix omega)
 						    (left-invert-matrix omega))))))
 	    		   (args :any :any (lambda (omega alpha)
 					     (array-inner-product (invert-matrix omega)
 								  alpha (lambda (arg1 arg2)
 									  (apply-scalar-dyadic #'* arg1 arg2))
 								  #'+))))
 	       (tests (is "⌹1 2 3 4" #(1/30 1/15 1/10 2/15))
 		      (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))
 		      (is "⌹4 2⍴1 3 ¯4 9" #2A((3/14 -1/14 3/14 -1/14) (2/21 1/42 2/21 1/42)))
 		      (is "35 89 79⌹3 3⍴3 1 4 1 5 9 2 6 5" #(193/90 739/90 229/45))
 		      (is "(3 2⍴1 2 3 6 9 10)⌹3 3⍴1 0 0 1 1 0 1 1 1" #2A((1 2) (2 4) (6 4)))))
 	    (⍋ (has :titles ("Grade Up" "Grade Up By"))
 	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state *apex-idiom*
 	    										    :atomic-vector)
 	    									  #'<=)
 							     (of-state *apex-idiom* :count-from))))
 	    		   (args :any :any (lambda (omega alpha) (grade (if (vectorp alpha)
 									    (index-of alpha omega)
 									    (array-grade alpha omega))
 	    								(alpha-compare (of-state *apex-idiom*
 	    											 :atomic-vector)
 	    									       #'<)
 									(of-state *apex-idiom* :count-from)))))
 	       (tests (is "⍋8 3 4 9 1 5 2" #(5 7 2 3 6 1 4))
 		      (is "⍋5 6⍴⍳16" #(1 4 2 5 3))
 		      (is "(2 5⍴'ABCDEabcde')⍋'ACaEed'" #(1 3 2 6 4 5))))
 	    (⍒ (has :titles ("Grade Down" "Grade Down By"))
 	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state *apex-idiom*
 	    										    :atomic-vector)
 	    									  #'>=)
 							     (of-state *apex-idiom* :count-from))))
 	    		   (args :any :any (lambda (omega alpha) (grade (if (vectorp alpha)
 									    (index-of alpha omega)
 									    (array-grade alpha omega))
 	    								(alpha-compare (of-state *apex-idiom*
 	    											 :atomic-vector)
 	    									       #'>)
 									(of-state *apex-idiom* :count-from)))))
 	       (tests (is "⍒6 1 8 2 4 3 9" #(7 3 1 5 6 4 2))
 		      (is "⍒5 6⍴⍳12" #(2 4 1 3 5))
 		      (is "(2 5⍴'ABCDEabcde')⍒'ACaEed'" #(5 4 6 2 3 1))))
 	    (⊤ (has :title "Encode")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (flet ((rebase (bases number)
 	    					  (let ((operand number)
 	    						(last-base 1)
 	    						(base 1)
 	    						(component 1)
 	    						(element nil))
 	    					    (loop for index from (1- (length bases)) downto 0
 	    					       do (setq last-base base
 	    							base (* base (aref bases index))
 	    							component (if (= 0 base)
 	    								      operand
 	    								      (* base
 	    									 (nth-value 1 (floor (/ operand
 	    												base)))))
 	    							operand (- operand component)
 	    							element (/ component last-base))
 	    					       collect element))))
 	    				   (if (= 1 (length omega))
 	    				       (let ((result (rebase alpha (aref omega 0))))
 	    					 (make-array (list (length result))
 	    						     :initial-contents (reverse result)))
 	    				       (aops:permute (list 1 0)
 	    						     (make-array (list (length omega) (length alpha))
 	    								 :initial-contents
 	    								 (mapcar (lambda (item)
 	    									   (reverse (rebase alpha item)))
 	    									 (array-to-list omega)))))))))
 	       (tests (is "1760 3 12⊤82" #(2 0 10))
 		      (is "16 16 16 16⊤100" #(0 0 6 4))
 		      (is "2 2 2 2 2⊤1 2 3 4 5" #2A((0 0 0 0 0) (0 0 0 0 0) (0 0 0 1 1)
 						    (0 1 1 0 0) (1 0 1 0 1)))))
 	    (⊥ (has :title "Decode")
 	       (dyadic (args :any :any (lambda (omega alpha)
 	    				 (flet ((rebase (bases numerators)
 	    					  (let ((result 0)
 	    						(base 1))
 	    					    (loop for index from (1- (length numerators)) downto 0
 	    					       do (incf result (* base (aref numerators index)))
 	    						 (setf base (* base (aref bases index))))
 	    					    result)))
 	    				   (let ((bases (if (= 1 (length alpha))
 	    						    (make-array (list (first (dims omega)))
 	    								:initial-element (aref alpha 0))
 	    						    (if (not (= (length alpha)
 	    								(let ((d-o (dims omega)))
 	    								  (if (= 1 (length d-o))
 	    								      (first d-o)
 	    								      (second d-o)))))
 	    							(error "Base/element length mismatch.")
 	    							alpha))))
 	    				     (if (= 1 (rank omega))
 	    					 (vector (rebase bases omega))
 	    					 (aops:margin (lambda (sub-array) (rebase bases sub-array))
 	    						      omega 0)))))))
 	       (tests (is "10⊥2 6 7 1" 2671)
 		      (is "1760 3 12⊥2 2 5" 101)
 		      (is "1760 3 12⊥3 3⍴1 2 1 5 0 2 2 3 7" #(98 75 67))))
 	    (⍎ (has :title "Evaluate")
 	       (monadic (macro (lambda (meta axes omega)
 				 (declare (ignore meta axes))
 				 `(apex ,omega))))
 	       (tests (is "⍎'1+1'" 2)))
 	    (∘ (has :title "Find Outer Product, Not Inner")
	    	       (symbolic :outer-product-designator)))

 (operators (← (has :title "Assign Result Of")
 	       (right (macro (lambda (meta axes right-function)
 			       (declare (ignore meta axes))
 			       (lambda (meta unused omega alpha)
 				 (declare (ignore unused))
 				 (if (and (listp alpha)
 					  (eql 'aref-eliding (first alpha)))
 				     (append alpha (list :set `(lambda (item)
 								 (funcall (lambda (omega alpha)
 									    ,(funcall right-function
 										      meta nil 'omega 'alpha))
									  ,omega item))))
 				     (let ((symbol (if (listp alpha)
 						       (second alpha)
 						       alpha)))
 				       `(setq ,symbol
 					      (funcall (lambda (omega alpha)
 							 ,(funcall right-function meta nil 'omega 'alpha))
 						       ,omega ,alpha))))))))
 	       (tests (is "a←3 2 1 ◊ a+←5 ◊ a" #(8 7 6))
 		      (is "a←3 2 1 ◊ a[2]+←5 ◊ a" #(3 7 1))))
 	    (/ (has :title "Reduce")
 	       (right (lambda (meta unused omega &optional alpha)
 	    		(declare (ignore unused alpha))
 	    		`(let ((new-array (copy-array ,omega)))
 	    		   (if (= 1 (rank new-array))
 	    		       (vector (reduce (lambda (omega alpha)
 	    					 (let ((alpha (if (arrayp alpha)
 	    							  alpha (vector alpha)))
 	    					       (omega (if (arrayp omega)
 	    							  omega (vector omega))))
 	    					   (disclose ,(funcall function meta nil 'omega 'alpha))))
 	    				       new-array))
 	    		       (aops:margin (lambda (sub-array) (reduce (lambda (omega alpha)
 	    								  (let ((alpha (if (arrayp alpha)
 	    										   alpha (vector alpha)))
 	    									(omega (if (arrayp omega)
 	    										   omega (vector omega))))
 	    								    (disclose
 	    								     ,(funcall function
 	    									       meta nil 'omega 'alpha))))
 	    								sub-array))
 	    				    new-array (if ,axes (1- (aref (first ,axes) 0))
 	    						  (1- (rank new-array))))))))
 	       (tests (is "+/1 2 3 4 5" 15)
 	    	      (is "+/3 4⍴⍳12" #(10 26 42))
 	    	      (is "+/[1]3 4⍴⍳12" #(15 18 21 24))
 	    	      (is "⌊10000×{⍺+÷⍵}/40/1" 16180)))
  	    (⌿ (has :title "Reduce First")
 	       (right (lambda (meta unused omega &optional alpha)
 	    		(declare (ignore unused alpha))
 	    		`(let ((new-array (copy-array ,omega)))
 	    		   (if (= 1 (rank new-array))
 	    		       (vector (reduce (lambda (omega alpha)
 	    					 (let ((alpha (if (arrayp alpha)
 	    							  alpha (vector alpha)))
 	    					       (omega (if (arrayp omega)
 	    							  omega (vector omega))))
 	    					   (disclose ,(funcall function meta nil 'omega 'alpha))))
 	    				       new-array))
 	    		       (aops:margin (lambda (sub-array) (reduce (lambda (omega alpha)
 	    								  (let ((alpha (if (arrayp alpha)
 	    										   alpha (vector alpha)))
 	    									(omega (if (arrayp omega)
 	    										   omega (vector omega))))
 	    								    (disclose
 	    								     ,(funcall function
 	    									       meta nil 'omega 'alpha))))
 	    								sub-array))
 	    				    new-array (if ,axes (1- (aref (first ,axes) 0))
 	    						  0))))))
 	       (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))
		      (is "{⍺×⍵+3}⌿3 4⍴⍳12" #(207 330 495 708))
 	    	      (is "+⌿[2]3 4⍴⍳12" #(10 26 42))))
 	    (\\ (has :title "Scan")
 	    	(right (lambda (meta unused omega &optional alpha)
 	    		 (declare (ignore unused alpha))
 	    		 `(if (vectorp ,omega)
 	    		      (funcall (make-back-scanner (lambda (omega alpha)
 	    						    (let ((alpha (if (arrayp alpha)
 	    								     alpha (vector alpha)))
 	    							  (omega (if (arrayp omega)
 	    								     omega (vector omega))))
 	    						      (disclose
 	    						       ,(funcall function meta nil 'omega 'alpha)))))
 	    			       ,omega)
 	    		      (if (arrayp ,omega)
 	    			  (apply-marginal (make-back-scanner (lambda (omega alpha)
 	    							       (let ((alpha (if (arrayp alpha)
 	    										alpha (vector alpha)))
 	    								     (omega (if (arrayp omega)
 	    										omega (vector omega))))
 	    								 (disclose
 	    								  ,(funcall function
 	    									    meta nil 'omega 'alpha)))))
 	    					  ,omega (if ,axes (1- (aref (first ,axes) 0)))
 	    					  (1- (rank ,omega)))))))
 	    	(tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
 	    	       (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))
 	    	       (is "+\\[1]3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
 	    (⍀ (has :title "Scan First")
 	       (right (lambda (meta unused omega &optional alpha)
 	    		(declare (ignore unused alpha))
 	    		`(if (vectorp ,omega)
 	    		     (funcall (make-back-scanner (lambda (omega alpha)
 	    						   (let ((alpha (if (arrayp alpha)
 	    								    alpha (vector alpha)))
 	    							 (omega (if (arrayp omega)
 	    								    omega (vector omega))))
 	    						     (disclose
 	    						      ,(funcall function meta nil 'omega 'alpha)))))
 	    			      ,omega)
 	    		     (if (arrayp ,omega)
 	    			 (apply-marginal (make-back-scanner (lambda (omega alpha)
 	    							      (let ((alpha (if (arrayp alpha)
 	    									       alpha (vector alpha)))
 	    								    (omega (if (arrayp omega)
 	    									       omega (vector omega))))
 	    								(disclose
 	    								 ,(funcall function
 	    									   meta nil 'omega 'alpha)))))
 	    					 ,omega (if ,axes (1- (aref (first ,axes) 0)))
 	    					 0)))))
 	       (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
 	    	      (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))
		      (is "{⍺×⍵+3}⍀3 4⍴⍳12" #2A((1 2 3 4) (20 30 42 56) (288 450 660 924)))
 	    	      (is "+⍀[2]3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
 	    (\. (has :title "Inner/Outer Product")
 	    	(center (macro (lambda (meta axes left-operand)
 	    			 (declare (ignore meta axes))
 	    			 (if (eq :outer-product-designator left-operand)
 	    			     (lambda (meta axes right-function)
 	    			       (declare (ignore meta axes))
 	    			       (lambda (meta unused omega alpha)
 	    				 (declare (ignore unused))
 	    				 `(aops:outer (lambda (omega alpha)
 	    						,(funcall right-function meta nil 'omega 'alpha))
 	    					      ,alpha ,omega)))
 	    			     (lambda (meta axes right-function)
 	    			       (declare (ignore meta axes))
 	    			       (lambda (meta unused omega alpha)
 	    				 (declare (ignore unused))
 	    				 `(if (and (vectorp ,omega)
 	    					   (vectorp ,alpha))
 	    				      ;; TODO: improve logic for the argument?
 	    				      (make-array (list 1)
 	    						  :initial-element
 	    						  (reduce (lambda (omega alpha)
 	    							    ,(funcall left-operand
 	    								      meta nil 'omega 'alpha))
 	    							  (aops:each (lambda (omega alpha)
 	    								       ,(funcall right-function
 	    										 meta nil 'omega 'alpha))
 	    								     ,alpha ,omega)))
 	    				      (array-inner-product ,alpha ,omega
 	    				      			   (let ((f1 (lambda (omega alpha)
 	    				      				       ,(funcall right-function
 	    				      						 meta nil 'omega 'alpha))))
 	    				      			     (lambda (arg1 arg2)
 	    				      			       (if (or (arrayp arg1)
 	    				      				       (arrayp arg2))
 	    				      				   (apply-scalar-dyadic f1 arg1 arg2)
 	    				      				   (funcall f1 arg1 arg2))))
 	    				      			   (lambda (omega alpha)
 	    				      			     ,(funcall left-operand
 	    				      				       meta nil 'omega 'alpha))))))))))
 	    	(tests (is "2 3 4+.×8 15 21" 145)
 	    	       (is "2 3 4+.×3 3⍴3 1 4 1 5 9 2 6 5" #(17 41 55))
 	    	       (is "(3 3⍴3 1 4 1 5 9 2 6 5)+.×2 3 4" #(25 53 42))
 	    	       (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))))
 	    (\¨ (has :title "Each")
 	    	(right (lambda (meta axes omega &optional alpha)
 	    		 (declare (ignore axes))
 	    		 `(let ((new-array (copy-array ,omega)))
			    ,(if alpha
				 `(let ((right-arg ,alpha))
				    (make-array (dims right-arg)
						:initial-contents
						(loop for index from 0 to (1- (length right-arg))
						   collect (funcall (lambda (omega alpha)
								      ,(funcall function
										meta nil 'omega 'alpha))
								    (aref new-array 0)
								    (vector (aref right-arg index))))))
				 `(aops:each (lambda (item) (funcall (lambda (omega)
								       ,(funcall function meta nil 'omega))
								     item))
					     new-array)))))
		(tests (is "⍳¨1 2 3" #(#(1) #(1 2) #(1 2 3)))
		       (is "1 ¯1 ⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
 	    (⍨ (has :title "Commute")
 	       (right (lambda (meta axes omega &optional alpha)
 	    		(funcall function meta axes (if alpha alpha omega)
 	    			 omega)))
 	       (tests (is "5-⍨10" 5)
		      (is "+⍨10" 20)))
 	    (∘ (has :title "Compose")
 	       (center (macro (lambda (meta axes left-operand)
 	    			(declare (ignore meta axes))
 	    			(compose-stage left-operand))))
 	       (tests (is "a←⍴∘⍴ ◊ a 2 3 4⍴⍳9" 3)
 	    	      (is "⍴∘⍴2 3 4⍴⍳9" 3)
 	    	      (is "⍴∘⍴∘⍴2 3 4⍴⍳9" 1)
 	    	      (is "⌊10000×+∘÷/40/1" 16180)))
 	    (⍣ (has :title "Power")
 	       (center (macro (lambda (meta axes left-function)
 	    			(declare (ignore meta axes))
 	    			(lambda (meta axes right-operand)
 	    			  (declare (ignore axes))
 	    			  (cond ((and (listp right-operand)
 	    				      (integerp (second right-operand)))
 	    				 (let ((arg (gensym)))
 	    				   `(lambda (omega &optional alpha)
 	    				      (declare (ignorable alpha))
 	    				      (let ((,arg omega))
 	    					(loop for index from 0 to ,(1- (second right-operand))
 	    					   do (setq ,arg (enclose ,(funcall left-function meta nil arg))))
 	    					,arg))))
 	    				((listp right-operand)
 	    				 (let ((arg (gensym)))
 	    				   `(lambda (omega &optional alpha)
 	    				      (declare (ignorable alpha))
 	    				      (let ((,arg omega))
 	    					(loop while (not (= 0 (funcall ,right-operand ,arg)))
 	    					   do (setq ,arg (enclose ,(funcall left-function meta nil arg))))
 	    					,arg)))))))))
 	       (tests (is "fn←{2+⍵}⍣3 ◊ fn 5" 11)
 	    	      (is "({2+⍵}⍣3) 9" 15)
 	    	      (is "fn←{2+⍵}⍣{10>⍵} ◊ fn 2" 10))))

 (general-tests (with :title "Basic function definition and use, with comments."
 		      :in ("⍝ This code starts with a comment.
                            f1←{⍵+3} ◊ f2←{⍵×2} ⍝ A comment after the functions are defined.
                            ⍝ This is another comment.
                            f2 f1 1 2 3 4 5")
 		      :ex #(8 10 12 14 16))
 		(with :title "Monadic inline function."
 		      :in ("{⍵+3} 3 4 5")
 		      :ex #(6 7 8))
 		(with :title "Dyadic inline function."
 		      :in ("1 2 3 {⍺×⍵+3} 3 4 5")
 		      :ex #(6 14 24))
 		(with :title "Variable-referenced values, including an element within an array, in a vector."
 		      :in ("a←9 ◊ b←2 3 4⍴⍳9 ◊ 1 2 a 3 b[1;2;1]")
 		      :ex #(1 2 9 3 5))
 		(with :title "Assignment of an element within an array."
 		      :in ("a←2 3⍴⍳9 ◊ a[1;2]←20 ◊ a")
 		      :ex #2A((1 20 3) (4 5 6)))
 		(with :title "Selection from an array with multiple elided dimensions."
 		      :in ("(2 3 3 4 5⍴⍳9)[2;;3;;2]")
 		      :ex #2A((6 2 7 3) (3 8 4 9) (9 5 1 6)))
 		(with :title "Elided assignment."
 		      :in ("a←2 3 4⍴⍳9 ◊ a[2;;3]←0 ◊ a")
 		      :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 0 7) (8 9 0 2) (3 4 0 6))))
 		(with :title "Elided assignment of applied function's results."
 		      :in ("a←2 3 4⍴⍳9 ◊ a[2;;3]+←10 ◊ a")
 		      :ex #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3)) ((4 5 16 7) (8 9 11 2) (3 4 15 6))))
		(with :title "Elision and indexed array elements."
		      :in ("(6 8⍴⍳9)[1 4;]")
		      :ex #2A((1 2 3 4 5 6 7 8) (7 8 9 1 2 3 4 5)))
		(with :title "As above but more complex."
		      :in ("(6 8 5⍴⍳9)[1 4;;2 1]")
		      :ex #3A(((2 1) (7 6) (3 2) (8 7) (4 3) (9 8) (5 4) (1 9))
			      ((5 4) (1 9) (6 5) (2 1) (7 6) (3 2) (8 7) (4 3))))))
